# 第十一章 测试概述

测试是编程的一部分。事实上，当你第一次编写计算机程序时，你肯定会将一些样本数据作为输入写入计算机程序，来观测它是否如你所期望的那样运行。很长一段时间以来，软件测试的测试过程都显得非常类似，很大程度上是手动进行的并且容易出错。然而，自21世纪初以来，软件行业的测试方法发生了巨大的变化，以应对现代软件系统的规模和复杂性。这一演变的核心是开发驱动的自动化测试实践。

自动化测试可以发现绝大多数漏洞并防止漏洞影响软件用户使用。在开发周期中，一个漏洞被发现的越晚，修复漏洞的代价就越大；并且在许多情况下是指数级增长的。然而，“发现漏洞”只是自动化测试的动机的一部分。你想要测试你的软件的一个相当重要的原因是支持更新换代的能力。无论是添加新功能、进行基于代码规范的代码重构，还是进行更大规模的重新设计，自动化测试都可以快速发现错误，使软件更新换代成为可能。

迭代更新速度更快的公司可以更快地适应不断变化的技术、市场条件和客户爱好。如果你有一个健壮的测试流程，你不必害怕改变 — 你可以把它作为开发软件的一个基本品质。当你越想更快更全面地改变你的系统，你就越需要一种快速的方法来测试它们。

编写测试的行为也改进了系统的设计。作为代码的第一个客户，测试可以告诉你很多关于设计选择的问题。比如，您的系统与数据库的耦合是否过于紧密？接口是否支持要求的用例？您的系统能处理所有的边缘样例吗？编写自动化测试迫使你在早期开发周期就考虑这些问题。这样做通常会导致软件更模块化，从而在以后实现更大的灵活性。

关于软件测试这个主题，已经有了很多的研究成果，而且有很好的理由: 对于这样一个重要的实践来说，做好它对许多人来说似乎仍然是一项神秘的工作。在谷歌，虽然我们已经取得了很大的进步，但我们仍然面临着使我们的流程在整个公司可靠扩展的难题。在这一章中，我们将分享一些我们所学到的东西，以帮助进一步的讨论。

## 我们为什么编写测试？

为了更好地理解如何最大限度地利用测试，让我们从头开始描述。当我们谈论自动化测试时，我们真正在谈论什么？

最简单的测试是这么定义的：

 - 只进行单个行为的测试，通常是你正在调用的方法或应用程序接口
 - 只有一个特定的输入，你传递给应用程序接口的一些数值
 - 可观察的输出或行为
 - 可控制的环境，如单个隔离过程

当你执行这样的测试，将输入传递给系统并验证输出时，你将了解系统是否如你所期望的那样运行。总的来说，数百或数千个简单的测试(通常称为测试套件)可以告诉你，你的整个产品符合预期设计的程度，更重要的是，当它不符合预期设计时，测试也会提醒你。

创建和维护一个健壮的测试套件需要真正的努力。随着代码库的增长，测试套件也会增长。它将开始面临不稳定和缓慢等挑战。如果不能解决这些问题，测试套件就会瘫痪。请记住，测试的价值来自工程师对它们的信任。如果测试成为生产力的一个阻碍，不断地引发辛劳和不确定性，工程师将失去信任，并开始寻找解决办法。一个糟糕的测试套件可能比没有测试套件更糟糕。

除了让公司能够快速制造出优秀的产品，在我们的生活中测试对于确保重要产品和服务安全至关重要。软件比以往任何时候都更加深入我们的生活，缺陷会导致很多烦恼：它们会花费大量的金钱，损失财产，或者最糟糕的是，导致我们失去美好生活。

在谷歌，我们已经确定测试不能是开发完成后的想法。关注质量和测试是我们工作的一部分。我们已经深刻地认识到，无法将质量融入我们的产品和服务不可避免地会导致糟糕的结果。因此，我们已经将测试纳入了我们工程文化的核心。

### 谷歌网络服务器的故事

在谷歌早期，工程师驱动的测试通常被认为不重要。团队经常依靠聪明的人来保证软件的正确。一些系统运行大型集成测试，但主要还是在开拓时期。一种产品似乎受到了特别严重的影响：它是谷歌网络服务器，也被称为GWS。

GWS是负责服务谷歌搜索查询的网络服务器，它对谷歌搜索的重要性不亚于机场的空中交通控制。早在2005年，随着项目规模和复杂性的膨胀，生产率急剧下降。发布变得越来越麻烦，推出它们需要越来越长的时间。团队成员在对服务进行更改时信心不足，并且通常只有在功能停止工作时才发现有问题。(另一点，超过80%的生产推送包含影响用户的漏洞，这些漏洞必须回滚。)

为了解决这些问题，GWS的技术负责人(TL)决定制定一项由工程师驱动的自动化测试政策。作为该策略的一部分，所有新的代码更改都需要包含测试，并且这些测试将持续运行。在制定这项政策的一年内，紧急推送的数量减少了一半。尽管该项目每个季度都有创纪录的变化，但这种减少还是发生了。即使面对前所未有的增长和变化，测试也给谷歌最关键的项目带来了新的生产力和信心。今天，GWS有成千上万的测试，并且几乎每天都发布只有相对较少的客户可见的漏洞。

GWS的变化标志着谷歌测试文化的分水岭，因为公司其他部门的团队看到了测试的好处，并采取了类似的策略。

GWS的经历告诉我们的一个关键观点是你不能仅仅依靠程序员的能力来避免产品缺陷。即使每个工程师只编写很少的错误，当你有足够的人在同一个项目上工作时，你将被不断增长的缺陷清单淹没。想象一个100人的团队，他们的工程师非常优秀，每个人每个月只写一个漏洞。总体来说，这群了不起的工程师每个工作日仍然会产生五个新的漏洞。更糟糕的是，在一个复杂的系统中，修复一个错误往往会导致另一个错误，因为工程师可能基于已知的错误并编写接下来的代码。

最好的团队会想办法将成员的集体智慧转化为整个团队的利益。这正是自动化测试所做的。在团队中的一个工程师编写了一个测试后，它被添加到其他人可用的公共资源池中。团队中的其他每个人现在都可以运行测试，并且当它检测到问题时将会受益。与此形成对比的是基于调试的方法，在这种方法中，每次错误发生时，工程师都必须花费用调试器深入调查的开销。工程资源的成本日以继夜投入，这是GWS能够扭转其命运的根本原因。

### 以现代化发展的速度进行测试

软件系统变得越来越大，越来越复杂。谷歌的典型应用程序或服务由数千或数百万行代码组成。它使用各种库或框架，通过不可靠的网络交付给越来越多的平台，这些平台运行着无数的配置。更糟糕的是，新版本频繁被推送给用户，甚至有时一天多次。这与一年只更新一两次的安装包包装软件的世界相去甚远。

人类手动验证系统中每个功能的能力已经跟不上大多数软件中功能和平台的爆炸式增长。想象一下手动测试谷歌搜索的所有功能需要什么，例如寻找航班、电影时间、相关图像，当然还有网络搜索结果(见图11-1)。即使你能确定如何解决这个问题，你也需要将这个工作量乘以谷歌搜索必须支持的每种语言、国家和设备，并且不要忘记检查可访问性和安全性。试图通过要求人们手动与每一个特征交互来评估产品质量是不可行的。谈到测试，有一个明确的答案可以实现这一点：自动化。
![image-20210428183927257](https://gitee.com/yyjjtt/picture_bed/raw/master/img/image-20210428183927257.png)

### 编程，运行，反应

在其最纯粹的形式中，自动化测试由三个活动组成：编写测试、运行测试和对测试失败做出反应。自动化测试是一小段代码，通常是一个单独的函数或方法，它调用你想要测试的更大系统的一个独立部分。测试代码建立一个预期的环境，调用系统，通常使用一个已知的输入，并验证结果。有些测试非常小，使用单一的代码路径；另一些测试要大得多，可能涉及整个系统，比如移动操作系统或网络浏览器。

示例 11-1展示了一个谨慎的用Java进行的简单测试，不使用框架或测试库。这并不是你编写整个测试套件的方式，但是在它的核心，每个自动化测试看起来都类似于这个非常简单的例子。

*示例 11-1.一个简单的测试*

```java
// 验证计算机类可以处理一个负的结果
public void main(String[] args) {
   Calculator calculator = new Calculator();
   int expectedResult = -3;
   int actualResult = calculator.subtract(2, 5); // Given 2, Subtracts 5.
   assert(expectedResult == actualResult);
}
```

与过去的质量保证过程不同，在过去的质量保证过程中，专门的软件测试人员仔细研究系统的新版本，测试每一种可能的行为，今天构建系统的工程师在为他们自己的代码编写和运行自动化测试方面发挥着积极和不可或缺的作用。即使在质量保证是一个部门的公司里，开发人员编写测试也很常见。以当今系统开发的速度和规模，唯一的方法是让整个工程人员共享测试的开发。

当然，写测试和写好测试是不同的。培养成千上万的工程师来编写好的测试可能相当困难。我们将在接下来的章节中讨论我们所学到的关于编写好的测试的知识。

编写测试只是自动化测试过程的第一步。写完测试后，你需要运行它们。自动化测试其核心包括一遍又一遍地重复相同的动作，只有在出现故障时才需要人工注意。我们将在第23章讨论这种持续集成和测试。通过将测试表示为代码，而不是手动的一系列步骤，我们可以在每次代码更改时运行它们—很容易每天就能运行数千次。与人类测试人员不同，机器永远不会疲劳或厌倦。

将测试表示为代码的另一个好处是，很容易将它们模块化，以便在各种环境中执行。只要你已经为这两个系统进行了配置，在谷歌中进行了谷歌邮件测试就不需要在火狐中测试谷歌邮件花销更多的资源。可以使用与英语相同的测试代码来运行日语或德语用户界面的测试。

正在积极开发的产品和服务将不可避免地经历测试失败。真正使测试过程有效的是它如何解决测试失败。允许失败的测试快速堆积会破坏它们提供的任何价值，所以绝对不能让这种情况发生。优先在失败后几分钟内修复失败测试的团队能够保持高信心和快速的故障隔离，因此从他们的测试中可以获得更多的价值。

总之，健康的自动化测试文化鼓励每个人分享编写的测试。这样的文化也确保了测试的定期运行。最后，也可能是最重要的，它强调快速修复失败的测试以便在过程中保持高度的信心。

### 测试代码的好处

对于来自没有强大测试文化的组织的开发人员来说，将编写测试作为提高生产率和速度的一种手段的想法似乎是对立的。毕竟，与实现一个功能首先要做的事情相比，编写测试的行为可能需要同样长的时间(甚至更长！)。相反，在谷歌，我们发现投资软件测试对开发人员的工作效率有几个主要好处：

*__更少的调试__*  
正如你所期望的那样，测试过的代码在提交时缺陷较少。关键是，它在整个存在过程中也有较少的缺陷；他们中的大多数缺陷会在提交代码之前被抓住。谷歌的一段代码预计在被完全弃用前会被修改几十次。它将被其他团队甚至自动化代码维护系统所改变。一次编写的测试将继续带来回报，并在项目的整个生命周期中防止代价高昂的缺陷和烦人的调试会话。同时可以通过测试基础结构快速检测出破坏测试的项目更改或项目的依存关系，并在问题发布到生产环境之前回滚。

*__增强对变更的信心__*  
所有软件变更。具有良好测试的团队可以自信地评审和接受他们项目的变更，因为他们项目的所有重要行为都被不断地验证。这样的项目鼓励重构。在保留现有行为的同时重构代码的更改（理想情况下）应不需要更改现有测试。

*__改良的文档__*  
软件文档是出了名的不可靠。从过时的需求到缺失的边缘情况，文档与代码之间的关系很脆弱是很常见的。清晰、集中的测试，一次测试一个行为，起到可执行文档的作用。如果你想知道代码在特定情况下做什么，请查看该情况下的测试。更好的是，当需求改变并且新代码破坏了现有的测试时，我们得到了一个明确的信号，即“文档化”现在已经过时了。请注意，只有在注意保持测试清晰和简洁的情况下，测试作为文档才最有效。

*__更简单的审查__*  
谷歌的所有代码都要经过至少一名其他工程师的审查，然后才能提交(详见第9章)。如果代码审查包括证明代码正确性、边缘情况和错误条件的全面测试，则代码审查人员在验证代码是否如预期那样工作方面花费的精力较少。审查者可以验证每个案例都通过了测试，而不是在精神上遍历每个案例所需要的繁琐工作。

*__周到的设计__*
为新代码编写测试是练习代码本身的接口设计的一种实用方法。如果新代码难以测试，通常是因为被测试的代码有太多的分支或者难以管理的依赖关系。设计良好的代码应该是模块化的，避免紧密耦合，专注于特定的责任。尽早解决设计问题通常意味着以后更少的返工。

*__快速、高质量的发布__*    
有了一个健康的自动化测试套件，团队可以放心地发布他们应用程序的新版本。谷歌的许多项目每天都会发布一个新的生产版本—甚至是每天都有数百名工程师和数千条代码变更提交的大型项目。没有自动化测试，这是不可能的。

## 设计一个测试套件

今天，谷歌以巨大的规模运作着，但我们并不总是如此庞大，我们方法的基础在很久以前就奠定了。多年来，随着我们代码库的增长，通过不断出错纠错,我们学到了很多关于如何设计和执行测试套件的方法。
我们很早就得出的一个经验使工程师们喜欢写较大的、系统级规模的测试，但这些测试比小的测试更慢、更不可靠、更难调试。工程师们厌倦了对系统级规模测试的调试，他们问自己，"为什么我们不能一次只测试一台服务器？"或者，"为什么我们需要一次测试整个服务器？我们可以单独测试较小的模块"。最终，减少痛苦的愿望导致团队开发出越来越小的测试，结果是更快，更稳定，而且一般来说不那么痛苦。
这导致了公司内部对 "小 "的确切含义的大量讨论。小是指单元测试吗？那集成测试呢，是什么规模？我们得出的结论是，每个测试案例都有两个不同的维度：规模和范围。规模是指运行一个测试用例所需的资源：如内存、进程和时间。范围指的是我们要验证的具体代码路径。请注意，执行一行代码与验证它是否按预期工作是不同的。规模和范围是相互关联但不同的概念。

### 测试规模

在谷歌，我们把每一个测试都归为一个规模，并鼓励工程师总是为一个给定的功能编写尽可能小的测试。一个测试的规模不是由它的代码行数决定的，而是由它的运行方式、它被允许做什么以及它消耗多少资源决定的。事实上，在某些情况下，我们对小、中、大的定义实际上被编码为测试基础设施可以在测试上执行的约束。我们稍后会讨论这些细节，但简而言之，小型测试在单个进程中运行，中型测试在单个机器上运行，而大型测试则在任何地方运行，如图 11-2 所示。

![image-20210425225744858](https://gitee.com//yyjjtt/picture_bed/raw/master/img/20210425225752.png)

我们做出这样的区分，而不是更传统的 "单元 "或 "集成"，因为我们希望从我们的测试套件中得到的最重要的品质是速度和确定性，这与测试的范围如何无关。小型测试，无论范围如何，几乎总是比涉及更多基础设施或消耗更多资源的测试更快、更有确定性。对小型测试施加限制，使速度和确定性更容易实现。随着测试规模的增长，许多限制都被放松了。中型测试有更多的灵活性，但也有更多的非确定性的风险。较大的测试只保存在最复杂和困难的测试场景中。让我们仔细看看对每种类型的测试施加的确切限制。

#### 小型测试

小型测试是三种测试规模中最受限制的。主要的约束是，小测试必须在一个进程中运行。在许多语言中，我们甚至进一步限制，说它们必须在一个单线程上运行。这意味着执行测试的代码必须与被测试的代码在同一进程中运行。你不能运行一个服务器，而让一个单独的测试进程连接到它。这也意味着你不能运行第三方程序，如让数据库作为你测试的一部分。

对小型测试的其他重要限制是，他们不允许睡眠，执行I/O操作，或进行任何其他阻塞性调用。这意味着，小测试不允许访问网络或磁盘。测试依赖这类操作的代码需要使用测试替代（见第13章），用轻量级的进程内依赖取代重量级依赖。

这些限制的目的是确保小的测试不能接触到测试速度慢或不确定性的主要来源。一个在单个进程上运行并且从不进行阻塞调用的测试可以有效地运行到CPU可以处理的最快速度。很难（但肯定不是不可能）意外地使这样的测试变得缓慢或不确定。对小型测试的限制提供了一个沙盒，防止工程师们自寻烦恼。

这些限制一开始可能看起来很过分，但考虑到一个由几百个小测试案例组成的适度的套件在一天中运行。如果其中有几个非确定性地失败（通常被称为flaky test），追踪原因就会成为生产力的严重消耗。在谷歌的规模下，这样的问题会使我们的测试基础设施陷入停顿。

在Google，我们鼓励工程师尽可能地编写小型测试，不管测试的范围如何，因为这样可以保持整个测试套件快速可靠地运行。关于小型测试与单元测试的更多讨论，见第12章。

#### 中型测试

对于许多有趣的测试来说，对小型测试的限制可能过于严格。测试规模的下一个阶梯是中型测试。中型测试可以跨越多个进程，使用线程，并可以进行阻塞性调用，包括网络调用localhost。剩下的唯一限制是，中型测试不允许对 localhost 以外的任何系统进行网络调用。换句话说，测试必须包含在一台机器内。

运行多个进程的能力开辟了很多可能性。例如，你可以运行一个数据库实例，以验证你正在测试的代码在一个更现实的环境中正确集成。或者你可以测试网络用户界面和服务器代码的组合。网络应用程序的测试经常涉及到像WebDriver这样的工具，它可以启动一个真正的浏览器，并通过测试过程远程控制它。

不幸的是，随着灵活性的增加，测试变得缓慢和不确定的可能性也在增加。跨进程的测试或被允许进行阻塞调用的测试依赖于操作系统和第三方进程的快速和确定性，这在一般情况下我们是无法保证的。中等测试仍然通过防止通过网络访问远程机器来提供一些保护，而网络是大多数系统中速度慢和非确定性的最大来源。尽管如此，在编写中型测试时，"安全 "是关闭的，工程师需要更加小心。

#### 大型测试

最后，我们有大型测试。大型测试取消了对中型测试的本地主机限制，允许测试和被测系统跨越多台机器。例如，测试可能针对远程集群中的系统运行。

和以前一样，灵活性的增加伴随着风险的增加。与在单台机器上运行相比，必须处理一个跨越多台机器和连接它们的网络的系统，大大增加了速度慢和不确定的机会。我们大多将大型测试保留给全系统的端到端测试，这些测试更多的是验证配置而不是代码片断，以及测试那些不可能使用测试替代的遗留组件。我们将在第14章讨论更多关于大型测试的用例。谷歌的团队经常将他们的大型测试与小型或中型测试隔离开来，只在构建和发布过程中运行，以免影响开发人员的工作流程。

**案例学习:flaky test是昂贵的**

如果你有几千个测试，每个测试都有非常小的非确定性，整天运行，偶尔会有一个可能会失败（flaky）。随着测试数量的增加，从统计学上看，flaky的数量也会增加。如果每个测试都有0.1%的失败率，而你每天运行10,000个测试，你每天将调查10个flaky。每次调查都会占用你的团队可以做的更有成效的事情的时间。

在某些情况下，你可以通过在测试失败时自动重新运行它们来限制故障测试的影响。这实际上是用CPU周期换取工程时间。在低水平的不稳定情况下，这种权衡是有意义的。只要记住，重新运行测试只是推迟了解决故障根源的需要。

如果测试松散性继续增长，你将经历比生产力损失更糟糕的事情：对测试失去信心。在一个团队失去对测试套件的信任之前，并不需要调查许多缺陷。发生这种情况后，工程师将停止对测试失败的反应，消除测试套件提供的任何价值。我们的经验表明，当你接近1%的flaky率时，测试开始失去价值。在谷歌，我们的失误率徘徊在0.15%左右，这意味着每天有成千上万的失误。我们努力控制flaky，包括积极投入工程时间来修复片断。

在大多数情况下，flaky的出现是因为测试本身的非确定性行为。软件提供了许多非确定性的来源：时钟时间、线程调度、网络延迟，等等。学习如何隔离和稳定随机性的影响并不容易。有时，影响与硬件中断或浏览器渲染引擎等低级别的问题联系在一起。一个好的自动化测试基础设施应该帮助工程师识别和缓解任何非确定性行为。

**所有测试规模的共同属性**

所有的测试都应该努力做到密封性：一个测试应该包含所有必要的信息来设置、执行和关闭其环境。测试应该尽可能少地假设外部环境，如测试的运行顺序。例如，他们不应该依赖共享数据库。这种限制在大型测试中变得更加具有挑战性，但仍应努力确保隔离。

一个测试应该只包含行使有关行为所需的信息。保持测试的清晰和简单，有助于审查者验证代码是否做了它所说的事情。清晰的代码也有助于在失败时诊断失败。我们喜欢说，"测试应该在检查时是明显的"。因为没有对测试本身的测试，所以需要人工审查作为对正确性的重要检查。作为一个推论，我们也**强烈不鼓励在测试中使用控制流语句，如条件语句和循环语句**。更加复杂的测试流程有可能包含错误本身，并使确定测试失败的原因更加困难。

请记住，测试通常只有在发生故障时才会被重新审视。当你被要求修复一个你以前从未见过的坏掉的测试时，你会感谢有人花时间使它变得容易理解。代码被阅读的次数远远多于被写的次数，所以要确保你写的测试是你想读的

**实践中的测试规模**。有了测试规模的精确定义，我们就可以创建工具来强制执行它们。强制执行使我们能够扩展我们的测试套件，并且仍然能够对速度、资源利用率和稳定性做出一定的保证。在谷歌，这些定义的执行程度因语言而异。例如，我们使用一个自定义的安全管理器来运行所有的Java测试，如果它们试图做一些被禁止的事情，如建立网络连接，就会导致所有被标记为小的测试失败。

### 测试范围

尽管我们在谷歌非常强调测试规模，但另一个需要考虑的重要属性是测试范围。测试范围是指一个特定的测试要验证多少代码。狭窄范围的测试（通常称为 "单元测试"）被设计用来验证代码库中一小部分的逻辑，比如一个单独的类或方法。中等范围的测试（通常称为集成测试）是为了验证少量组件之间的相互作用；例如，在服务器和数据库之间。大范围的测试（通常被称为功能测试，端到端测试，或系统测试）被设计用来验证系统的几个不同部分的交互，或不在一个单一的类或方法中表达的突发行为。

值得注意的是，当我们谈论单元测试是狭义的范围时，我们指的是正在验证的代码，而不是正在执行的代码。一个类有许多依赖关系或它引用的其他类是很常见的，这些依赖关系在测试目标类时自然会被调用。尽管其他一些测试策略大量使用了测试替代（fakes或mocks）来避免执行被测系统之外的代码，但在Google，在可行的情况下，我们更愿意保持真正的依赖关系。第13章更详细地讨论了这个问题。

狭窄范围的测试往往是小型的，而广泛范围的测试往往是中型或大型的，但这并不总是这样的。例如，有可能对一个服务器端点写一个大范围的测试，包括所有正常的解析、请求验证和业务逻辑，但这是小范围的，因为它用双倍数来代替所有进程外的依赖，如数据库或文件系统。同样的，也可以对一个单一的方法写一个狭义的测试，但必须是中等规模的。例如，现代网络框架经常将HTML和JavaScript捆绑在一起，测试一个UI组件，如日期选择器，往往需要运行整个浏览器，甚至验证一个单一的代码路径。

就像我们鼓励小规模的测试一样，在谷歌，我们也鼓励工程师编写范围较小的测试。作为一个非常粗略的指导原则，我们倾向于将80%的测试混合为狭义的单元测试，以验证大部分的业务逻辑；15%的中等范围的集成测试，以验证两个或多个组件之间的交互；以及5%的端到端测试，以验证整个系统。图11-3描述了我们如何以金字塔的形式来看待这个问题。

![image-20210425230552428](https://gitee.com//yyjjtt/picture_bed/raw/master/img/20210425230552.png)

单元测试是一个很好的基础，因为它们快速、稳定，并且极大地缩小了范围，减少了识别一个类或函数的所有可能行为所需的认知负荷。此外，它们使故障诊断变得快速而无痛。需要注意的两个反模式是 "冰激凌锥 "和 "沙漏"，如图11-4所示。

在冰激凌锥中，工程师们写了许多端到端的测试，但很少有集成或单元测试。这样的测试套件往往是缓慢的、不可靠的、难以操作的。这种模式经常出现在那些以原型开始的项目中，并迅速赶往生产，从来没有停止过解决测试的债务。

沙漏涉及许多端到端测试和许多单元测试，但很少有集成测试。它不像冰激凌锥那样糟糕，但它仍然导致许多端到端的测试失败，而这些失败本可以通过一套中等范围的测试更快、更容易地发现。沙漏模式发生在紧耦合使其难以孤立地实例化单个依赖关系的时候。

![image-20210425230623312](https://gitee.com//yyjjtt/picture_bed/raw/master/img/20210425230623.png)

我们推荐的测试组合是由我们的两个主要目标决定的：工程生产力和产品信心。在开发过程的早期，倾向于单元测试可以让我们迅速获得高的信心。在产品的开发过程中，大型测试作为理智的检查；它们不应该被看作是捕捉错误的主要方法。

当考虑你自己的组合时，你可能想要一个不同的平衡。如果你强调集成测试，你可能会发现你的测试套件需要更长的时间来运行，但在组件之间捕获更多的问题。当你强调单元测试时，你的测试套件可以很快完成，而且你会捕捉到许多常见的逻辑错误。但是，单元测试不能验证组件之间的相互作用，就像不同团队开发的两个系统之间的合同。一个好的测试套件包含不同的测试规模和范围的混合，适合于当地的架构和组织的实际情况。

### 碧昂斯规则

在指导新员工时，我们经常被问到，哪些行为或属性实际上需要被测试？直截了当的回答是：测试所有你不想破坏的东西。换句话说，如果你想确信一个系统表现出一个特定的行为，唯一的方法就是为它写一个自动化测试。这包括所有常见的嫌疑人，如测试性能、行为正确性、可及性和安全性。它还包括不太明显的属性，如测试系统如何处理故障。

我们对这一总体理念有一个名称：我们称之为碧昂斯规则。简而言之，它可以被陈述如下。"如果你喜欢它，那么你应该对它进行测试"。碧昂斯法则经常被负责对整个代码库进行修改的基础设施团队所引用。如果不相关的基础设施变化通过了你的所有测试，但仍然破坏了你的团队的产品，你就要负责修复它并增加额外的测试。

#### 失败的测试

一个系统必须考虑的最重要的情况之一是失败。失败是不可避免的，但是等待真正的灾难来发现系统对灾难的反应如何，是非常痛苦的。与其等待失败，不如写自动测试来模拟常见的失败类型。这包括在单元测试中模拟异常或错误，在集成和端到端测试中注入远程过程调用（RPC）错误或延迟。它还可以包括使用混沌工程等技术模拟对真实生产网络的巨大破坏。对不利条件的可预测和可控制的反应是一个可靠系统的标志。

### 关于代码覆盖率的说明

代码覆盖率是衡量哪些特征代码行被哪些测试所执行。如果你有100行代码，你的测试执行了其中的90行，你就有90%的代码覆盖率。
代码覆盖率经常被认为是理解测试质量的黄金标准指标，这一点是很不幸的。有可能用一些测试来锻炼大量的代码行，但从未检查过每一行是否在做任何有用的事情。这是因为代码覆盖率只衡量一行被调用的情况，而不是结果。（我们建议只测量小型测试的覆盖率，以避免执行大型测试时出现覆盖率膨胀）。

代码覆盖率的一个更隐蔽的问题是，像其他指标一样，它很快就变成了一个单独的目标。对于团队来说，建立一个预期的代码覆盖率标准是很常见的，例如，80%。起初，这听起来非常合理；你肯定希望至少有这么多的覆盖率。在实践中，发生的情况是，工程师们不是把80%当作一个底线，而是把它当作一个上限。很快，变化就开始了，覆盖率不超过80%。毕竟，为什么要做比指标要求更多的工作？

接近你的测试套件质量的一个更好的方法是思考被测试的行为。你有信心你的客户所期望的一切都能正常工作吗？你是否有信心能抓住你的依赖关系中的突发变化？你的测试是否稳定和可靠？像这样的问题是思考测试套件的一种更全面的方式。每个产品和团队都是不同的；有些会有难以测试的与硬件的交互，有些涉及到大量的数据集。试图用一个单一的数字来回答 "我们有足够的测试吗？"忽略了很多背景，不太可能是有用的。代码覆盖率可以提供一些对未测试代码的洞察力，但它不能替代对系统测试情况的批判性思考。